-- handles all the authentication, don't touch me

-- import requirements
local cjson = require("cjson")
local https = require("ssl.https")
local url = require("socket.url")


-- setup some app-level vars

local oauth = {
    app_id = "@APP_ID@",
    app_secret = "@APP_SECRET@",
    orgs_whitelist = {["@ORG@"]=true},

    scope = "repo,user,user:email",
    authorize_base_url = "https://github.com/login/oauth/authorize",
    access_token_url = "https://github.com/login/oauth/access_token",
    user_orgs_url = "https://api.github.com/user/orgs",
}

oauth.authorize_url = oauth.authorize_base_url.."?client_id="..oauth.app_id.."&scope="..oauth.scope

function oauth.request(url_string, method)
    local result_table = {}

    local url_table = {
      url = url.build(url.parse(url_string, {port = 443})),
      method = method,
      sink = ltn12.sink.table(result_table),
      headers = {
        ["accept"] = "application/json"
      }
    }

    local body, code, headers, status_line = https.request(url_table)

    local json_body = ""
    for i, value in ipairs(result_table) do json_body = json_body .. value end

    ngx.log(ngx.INFO, "body::", json_body)

    return {body=cjson.decode(json_body), status=code, headers=headers}
end

function oauth.get(url_string)
    return oauth.request(url_string, "GET")
end

function oauth.get_access_token(code)

    local params = {
        access_token_url=oauth.access_token_url,
        client_id=oauth.app_id,
        client_secret=oauth.app_secret,
        code=code,
        redirect_uri=oauth.redirect_uri,
    }

    local url_string = oauth.access_token_url.."?"..ngx.encode_args(params)

    return oauth.get(url_string)
end


function oauth.verify_user(access_token)
    local params = {access_token=access_token}
    local url_string = oauth.user_orgs_url.."?"..ngx.encode_args(params)
    local response = oauth.get(url_string)
    local body = response.body

    if body.error then
        return {status=401, message=body.error}
    end

    for i, org in ipairs(body) do
        ngx.log(ngx.INFO, org.login)

        if oauth.orgs_whitelist[org.login] then
            return {status=200, body={access_token=access_token, org=org, access_level=9001}}
        end
    end

    return {status=401, message='not authorized for any orgs'}
end

local args = ngx.req.get_uri_args()
if args.error and args.error == "access_denied" then
    ngx.status = ngx.HTTP_UNAUTHORIZED
    ngx.say('{"status": 401, "message": "'..args.error_description..'"}')
    return ngx.exit(ngx.HTTP_OK)
end


-- extract previous token from cookie if it is there
local access_token = ngx.var.cookie_NGAccessToken
if access_token then
    ngx.header["Set-Cookie"] = "NGAccessToken="..access_token.."; path=/;Max-Age=3000"
end

-- first lets check for a code where we retrieve
-- credentials from the api
if not access_token or args.code then
    if args.code then

        response = oauth.get_access_token(args.code)

        -- kill all invalid responses immediately
        if response.status ~= 200 or response.body.error then
            ngx.status = response.status
            ngx.header["Content-Type"] = "application/json"
            response.body.auth_wall = "something went wrong with the OAuth process"
            ngx.say(cjson.encode(response.body))
            ngx.exit(ngx.HTTP_OK)
        end

        -- decode the token
        access_token = response.body.access_token
    end

    -- both the cookie and proxy_pass token retrieval failed
    if not access_token then
        ngx.log(ngx.INFO, 'no access_token')
        -- Track the endpoint they wanted access to so we can transparently redirect them back
        if not ngx.var.uri == nil and ngx.var.uri ~= "/_callback" then
            ngx.header["Set-Cookie"] = "NGRedirectBack="..ngx.var.uri.."; path=/;Max-Age=120"
        else
            ngx.header["Set-Cookie"] = "NGRedirectBack=/; path=/;Max-Age=120"
        end

        -- Redirect to the /oauth endpoint, request access to ALL scopes
        return ngx.redirect(oauth.authorize_url)
    end
end

-- ensure we have a user with the proper access app-level
local verify_user_response = oauth.verify_user(access_token)
if verify_user_response.status ~= 200 then
    -- delete their bad token
    ngx.header["Set-Cookie"] = "NGAccessToken=deleted; path=/; Expires=Thu, 01-Jan-1970 00:00:01 GMT"

    -- Redirect 403 forbidden back to the oauth endpoint, as their stored token was somehow bad
    if verify_user_response.status == 403 then
        return ngx.redirect(oauth.authorize_url)
    end

    -- Disallow access
    ngx.status = verify_user_response.status
    ngx.say('{"status": 503, "message": "Error accessing oauth.api for credentials"}')
    return ngx.exit(ngx.HTTP_OK)
end

-- Ensure we have the minimum for access_level to this resource
if verify_user_response.body.access_level < 255 then
    -- Expire their stored token
    ngx.header["Set-Cookie"] = "NGAccessToken=deleted; path=/; Expires=Thu, 01-Jan-1970 00:00:01 GMT"

    -- Disallow access
    ngx.status = ngx.HTTP_UNAUTHORIZED
    ngx.say('{"status": 403, "message": "USER_ID "'..access_token..'" has no access to this resource"}')
    return ngx.exit(ngx.HTTP_OK)
end

-- Store the access_token within a cookie
ngx.header["Set-Cookie"] = "NGAccessToken="..access_token.."; path=/;Max-Age=3000"

-- Support redirection back to your request if necessary
local redirect_back = ngx.var.cookie_NGRedirectBack
if redirect_back then
    ngx.header["Set-Cookie"] = "NGRedirectBack=deleted; path=/; Expires=Thu, 01-Jan-1970 00:00:01 GMT"
    return ngx.location.capture(redirect_back)
end

-- Set some headers for use within the protected endpoint
ngx.req.set_header("X-USER-ACCESS-LEVEL", json.access_level)
ngx.req.set_header("X-USER-EMAIL", json.email)
